#!/usr/bin/env python3
"""
NBA Daily Stats Fetcher → Google Sheets
Hoopsmatic Suite

Fetches box scores for a given date using nba_api,
computes advanced stats (TS%, Game Score, RAT),
and pushes all player-game rows to a Google Sheet tab.

SETUP:
  1. pip install nba_api gspread google-auth
  2. Create a Google Cloud service account with Sheets API enabled
  3. Download the JSON key file
  4. Share your Google Sheet with the service account email
  5. Update CONFIG below with your sheet ID and key file path

USAGE:
  python daily_stats_fetcher.py                  # Fetch today's games
  python daily_stats_fetcher.py 2026-02-20       # Fetch specific date
  python daily_stats_fetcher.py 2026-02-15 2026-02-20  # Fetch date range
"""

import sys
import time
import json
from datetime import datetime, timedelta

# ============================================================
# CONFIG — Update these for your environment
# ============================================================
SERVICE_ACCOUNT_FILE = 'service_account.json'    # Path to your Google service account JSON
SPREADSHEET_ID = 'YOUR_SPREADSHEET_ID_HERE'      # Google Sheets spreadsheet ID
TAB_NAME = 'DailyStats'                          # Tab/sheet name to write to
SLEEP_BETWEEN_GAMES = 0.6                        # Seconds between API calls (rate limiting)

# ============================================================
# IMPORTS (with helpful error messages)
# ============================================================
try:
    from nba_api.stats.endpoints import scoreboardv3, boxscoretraditionalv2
except ImportError:
    print("ERROR: nba_api not installed. Run: pip install nba_api")
    sys.exit(1)

try:
    import gspread
    from google.oauth2.service_account import Credentials
except ImportError:
    print("ERROR: gspread/google-auth not installed. Run: pip install gspread google-auth")
    sys.exit(1)


# ============================================================
# GOOGLE SHEETS CONNECTION
# ============================================================
SCOPES = ['https://www.googleapis.com/auth/spreadsheets']

def connect_sheets():
    """Connect to Google Sheets and return the worksheet."""
    creds = Credentials.from_service_account_file(SERVICE_ACCOUNT_FILE, scopes=SCOPES)
    gc = gspread.authorize(creds)
    spreadsheet = gc.open_by_key(SPREADSHEET_ID)

    # Get or create the tab
    try:
        ws = spreadsheet.worksheet(TAB_NAME)
    except gspread.exceptions.WorksheetNotFound:
        ws = spreadsheet.add_worksheet(title=TAB_NAME, rows=1000, cols=40)
        # Write header row
        ws.update('A1', [HEADER_ROW])
        print(f"Created new tab '{TAB_NAME}' with headers.")

    return ws


# ============================================================
# HEADER DEFINITION
# ============================================================
HEADER_ROW = [
    'Date', 'GameID', 'Player', 'PersonID', 'Team', 'Opponent',
    'Home', 'MIN', 'PTS', 'FGM', 'FGA', '3PM', '3PA', 'FTM', 'FTA',
    'ORB', 'DRB', 'REB', 'AST', 'STL', 'BLK', 'TOV', 'PF', '+/-',
    'FG%', '3P%', 'FT%', 'TS%', 'GmScr', 'RAT',
    'HomeTeam', 'AwayTeam', 'HomeScore', 'AwayScore', 'GameStatus'
]


# ============================================================
# STAT COMPUTATION
# ============================================================
def compute_advanced(row):
    """Compute TS%, Game Score, and RAT from a stats row dict."""
    pts = row['PTS']
    fgm, fga = row['FGM'], row['FGA']
    fg3m, fg3a = row['3PM'], row['3PA']
    ftm, fta = row['FTM'], row['FTA']
    orb, drb, reb = row['ORB'], row['DRB'], row['REB']
    ast, stl, blk = row['AST'], row['STL'], row['BLK']
    tov, pf, pm = row['TOV'], row['PF'], row['+/-']

    # True Shooting %
    tsa = fga + 0.44 * fta
    ts = pts / (2 * tsa) if tsa > 0 else 0

    # Shooting percentages
    fg_pct = fgm / fga if fga > 0 else 0
    fg3_pct = fg3m / fg3a if fg3a > 0 else 0
    ft_pct = ftm / fta if fta > 0 else 0

    # Game Score (Hollinger)
    gm_scr = (pts + 0.4 * fgm - 0.7 * fga - 0.4 * (fta - ftm)
              + 0.7 * orb + 0.3 * drb + stl + 0.7 * ast
              + 0.7 * blk - 0.4 * pf - tov)

    # RAT — efficiency-weighted composite
    ts_factor = min(1.5, max(0.5, ts / 0.55 if tsa > 0 else 0.7))
    scoring_value = pts * ts_factor
    rat = (scoring_value + ast * 1.5 + reb * 1.0
           + stl * 2.5 + blk * 2.0 - tov * 2.0 + pm * 0.25)

    row['FG%'] = round(fg_pct, 4)
    row['3P%'] = round(fg3_pct, 4)
    row['FT%'] = round(ft_pct, 4)
    row['TS%'] = round(ts, 4)
    row['GmScr'] = round(gm_scr, 1)
    row['RAT'] = round(rat, 1)
    return row


# ============================================================
# PARSE MINUTES
# ============================================================
def parse_minutes(min_str):
    """Parse NBA minutes string (e.g. 'PT32M15.00S', '32:15', '32') into float."""
    if not min_str:
        return 0
    s = str(min_str)
    # PT32M15.00S format
    if 'PT' in s:
        import re
        m = re.match(r'PT(\d+)M([\d.]+)S', s)
        if m:
            return int(m.group(1)) + float(m.group(2)) / 60
        m = re.match(r'PT(\d+)M', s)
        if m:
            return int(m.group(1))
    # MM:SS format
    if ':' in s:
        parts = s.split(':')
        return int(parts[0]) + float(parts[1]) / 60
    # Plain number
    try:
        return float(s)
    except ValueError:
        return 0


# ============================================================
# FETCH GAMES FOR A DATE
# ============================================================
def fetch_games(date_str):
    """Fetch all games for a given date. Returns list of game dicts."""
    print(f"  Fetching scoreboard for {date_str}...")
    sb = scoreboardv3.ScoreboardV3(game_date=date_str, league_id='00')
    data = sb.get_dict()

    scoreboard = data.get('scoreboard', {})
    games = scoreboard.get('games', [])

    result = []
    for g in games:
        home = g.get('homeTeam', {})
        away = g.get('awayTeam', {})
        result.append({
            'gameId': g.get('gameId', ''),
            'status': g.get('gameStatus', 0),
            'statusText': g.get('gameStatusText', ''),
            'homeTeam': home.get('teamTricode', ''),
            'awayTeam': away.get('teamTricode', ''),
            'homeScore': home.get('score', 0),
            'awayScore': away.get('score', 0),
        })

    print(f"    Found {len(result)} games")
    return result


# ============================================================
# FETCH BOX SCORE FOR A GAME
# ============================================================
def fetch_box_score(game_id, date_str, game_meta):
    """Fetch box score for a single game. Returns list of player row dicts."""
    print(f"    Fetching box score for {game_meta['awayTeam']}@{game_meta['homeTeam']} ({game_id})...")

    box = boxscoretraditionalv2.BoxScoreTraditionalV2(game_id=game_id)
    data = box.get_dict()

    rows = []

    # Find PlayerStats result set
    for rs in data.get('resultSets', []):
        if rs['name'] == 'PlayerStats':
            headers = rs['headers']
            for p in rs['rowSet']:
                pdict = dict(zip(headers, p))

                minutes = parse_minutes(pdict.get('MIN', ''))
                if minutes <= 0:
                    continue  # Skip DNP

                team_tri = pdict.get('TEAM_ABBREVIATION', '')
                is_home = team_tri == game_meta['homeTeam']
                opponent = game_meta['awayTeam'] if is_home else game_meta['homeTeam']

                row = {
                    'Date': date_str,
                    'GameID': game_id,
                    'Player': pdict.get('PLAYER_NAME', ''),
                    'PersonID': pdict.get('PLAYER_ID', ''),
                    'Team': team_tri,
                    'Opponent': opponent,
                    'Home': 1 if is_home else 0,
                    'MIN': round(minutes, 1),
                    'PTS': int(pdict.get('PTS', 0) or 0),
                    'FGM': int(pdict.get('FGM', 0) or 0),
                    'FGA': int(pdict.get('FGA', 0) or 0),
                    '3PM': int(pdict.get('FG3M', 0) or 0),
                    '3PA': int(pdict.get('FG3A', 0) or 0),
                    'FTM': int(pdict.get('FTM', 0) or 0),
                    'FTA': int(pdict.get('FTA', 0) or 0),
                    'ORB': int(pdict.get('OREB', 0) or 0),
                    'DRB': int(pdict.get('DREB', 0) or 0),
                    'REB': int(pdict.get('REB', 0) or 0),
                    'AST': int(pdict.get('AST', 0) or 0),
                    'STL': int(pdict.get('STL', 0) or 0),
                    'BLK': int(pdict.get('BLK', 0) or 0),
                    'TOV': int(pdict.get('TO', 0) or 0),
                    'PF': int(pdict.get('PF', 0) or 0),
                    '+/-': int(pdict.get('PLUS_MINUS', 0) or 0),
                    'FG%': 0, '3P%': 0, 'FT%': 0, 'TS%': 0, 'GmScr': 0, 'RAT': 0,
                    'HomeTeam': game_meta['homeTeam'],
                    'AwayTeam': game_meta['awayTeam'],
                    'HomeScore': game_meta['homeScore'],
                    'AwayScore': game_meta['awayScore'],
                    'GameStatus': game_meta['statusText'],
                }

                row = compute_advanced(row)
                rows.append(row)

    print(f"      → {len(rows)} players")
    return rows


# ============================================================
# PUSH TO GOOGLE SHEETS
# ============================================================
def push_to_sheets(ws, all_rows, date_str):
    """Push player rows to the Google Sheet, replacing data for the given date."""
    if not all_rows:
        print(f"  No data to push for {date_str}")
        return

    # Read existing data to find and remove old rows for this date
    existing = ws.get_all_values()

    if len(existing) <= 1:
        # Empty sheet (just header or nothing) — write header + data
        header = [HEADER_ROW]
        data_rows = [[r.get(h, '') for h in HEADER_ROW] for r in all_rows]
        ws.update('A1', header + data_rows)
        print(f"  Wrote {len(data_rows)} rows (fresh sheet)")
        return

    # Filter out existing rows for this date
    header = existing[0]
    date_col = header.index('Date') if 'Date' in header else 0
    kept = [existing[0]]  # keep header
    for row in existing[1:]:
        if len(row) > date_col and row[date_col] == date_str:
            continue  # remove old data for this date
        kept.append(row)

    # Append new data
    new_rows = [[r.get(h, '') for h in HEADER_ROW] for r in all_rows]
    final = kept + new_rows

    # Clear and rewrite (handles row count changes)
    ws.clear()
    ws.update('A1', final)
    print(f"  Pushed {len(new_rows)} rows for {date_str} ({len(final) - 1} total rows)")


# ============================================================
# MAIN
# ============================================================
def process_date(date_str, ws):
    """Fetch and push all stats for a single date."""
    print(f"\n{'='*50}")
    print(f"Processing {date_str}")
    print(f"{'='*50}")

    games = fetch_games(date_str)
    if not games:
        print(f"  No games found for {date_str}")
        return 0

    all_rows = []
    for g in games:
        if g['status'] < 2:
            print(f"    Skipping {g['awayTeam']}@{g['homeTeam']} — not started yet")
            continue
        time.sleep(SLEEP_BETWEEN_GAMES)
        try:
            rows = fetch_box_score(g['gameId'], date_str, g)
            all_rows.extend(rows)
        except Exception as e:
            print(f"    ERROR fetching {g['gameId']}: {e}")

    # Sort by RAT descending
    all_rows.sort(key=lambda r: r['RAT'], reverse=True)

    push_to_sheets(ws, all_rows, date_str)
    return len(all_rows)


def main():
    # Parse arguments
    if len(sys.argv) == 1:
        # Today (Pacific time)
        from datetime import timezone
        now_utc = datetime.now(timezone.utc)
        pacific_offset = timedelta(hours=-8)  # PST (simplification)
        today = (now_utc + pacific_offset).strftime('%Y-%m-%d')
        dates = [today]
    elif len(sys.argv) == 2:
        dates = [sys.argv[1]]
    elif len(sys.argv) == 3:
        # Date range
        start = datetime.strptime(sys.argv[1], '%Y-%m-%d')
        end = datetime.strptime(sys.argv[2], '%Y-%m-%d')
        dates = []
        d = start
        while d <= end:
            dates.append(d.strftime('%Y-%m-%d'))
            d += timedelta(days=1)
    else:
        print("Usage: python daily_stats_fetcher.py [date] [end_date]")
        print("  No args     → fetch today")
        print("  One date    → fetch that date")
        print("  Two dates   → fetch date range")
        sys.exit(1)

    print(f"NBA Daily Stats Fetcher — Hoopsmatic")
    print(f"Dates to process: {', '.join(dates)}")

    # Connect to Google Sheets
    ws = connect_sheets()

    total = 0
    for date_str in dates:
        total += process_date(date_str, ws)
        if len(dates) > 1:
            time.sleep(1)  # Extra delay between dates

    print(f"\n✅ Done! {total} total player rows across {len(dates)} date(s).")


if __name__ == '__main__':
    main()
